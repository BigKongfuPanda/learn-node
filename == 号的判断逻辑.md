javascript 是弱类型语言，在进行 == 运算的时候 ，如果等号两边的数值类型不同的时候，会进行类型转换。

## 类型转换的逻辑算法

关于如何进行类型转换，ECMA 的标准里面有说明，如下所示：

```
The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:
1. If Type(x) is the same as Type(y), then
    - If Type(x) is undefined, return true;
    - If Type(x) is null, return true;
    - If Type(x) is Number, then
        - If x is NaN, return false;
        - If y is NaN, return false;
        - If x is the same Number value as y, return true;
        - If x is +0 and y is -0, return true;
        - If x is -0 and y is +0, return true;
        - Return false.
    - If Type(x) is String, then return true if x and y are exactly the same sequence of characters(same length and same characters in corresponding positions). Otherwise, return false;
    - If Type(x) is Boolean, return true if x and y are both true or both false. Otherwise, return false;
    - Return true if x and y refer to the same object. Otherwise, return false;

2. If x is null and y is undefined, return true;
3. If x is undefined and y is null, return true;
4. If Type(x) is Number and Type(y) is String, return result of the comparison of x == ToNumber(y);
5. If Type(x) is String and Type(y) is Number, return result of the comparison of ToNumber(x) == y;
6. If Type(x) is Boolean, return result of the comparison of ToNumber(x) == y;
7. If Type(y) is Boolean, return result of the comparison of x == ToNumber(y);
8. If Type(x) is either String or Number and Type(y) is Object, return result of the comparison of x == ToPrimitive(y);
9. If Type(x) is Object and Type(y) is either String or Number, return result of the comparison of ToPrimitive(x) == y;
10. Return false.
```

归纳起来，是按照以下的顺序来执行判断逻辑的：

1. 首先判断 `x` 和 `y` 的数据类型，如果数据类型相同，则判断值是否相同，如果相同则为 `true` , 否则为 `false`。其中需要注意的是 `Number` 类型，如果 x 和 y，二者中至少有一个为 `NaN`，则为 `false；`。如果类型不同，则会进行类型转换。
2. 如果 `x` 和 `y`，二者中一个为 `null` ，一个为 `undefined` ，则为 `true`；
3. 如果 `x 和 `y` 中，一个是 `Number` 类型，一个是 `String` 类型，则将 `String` 类型的数据转换为 `Number` 类型；
4. 如果 `x` 和 `y` 中，一个是 `Boolearn` 类型，则将 `Boolearn` 类型的数据转换为 `Number` 类型，`true -> 1`，`false -> 0`；
5. 如果 `x` 和 `y`，二者中一个为 `Object` ，另一个为 `Number` 或 `String` ，则为 会调用 `ToPrimitive(Object)`，然后再将其返回值跟另一个值进行比较；
6. 如果不满足上述的判断，则返回 `false` 。除了 `null` 和 `undefined` 以外，其他类型的数据，与 `null` 和 `undefined`
 进行 `==` 比较时，直接返回 `false`。

## ToPrimitive

上述中，当 x 和 y 中有一个是 Object 类型时，会先进行 ToPrimitive() 的运算，于是继续查找 ToPrimitive() 的标准。

> 7.1.1 ToPrimitive ( input [ , PreferredType ] )

> The abstract operation ToPrimitive takes an input argument and an optional argument PreferredType. The abstract operation ToPrimitive converts its input argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint PreferredType to favour that type. Conversion occurs according to the following algorithm:
> 1. Assert: input is an ECMAScript language value.
> 2. If Type(input) is Object, then
>    - If PreferredType is not present, let hint be "default".
>    - Else if PreferredType is hint String, let hint be "string".
>    - Else PreferredType is hint Number, let hint be "number".
>    - Let exoticToPrim be ? GetMethod(input, @@toPrimitive).
>    - If exoticToPrim is not undefined, then
>       - Let result be ? Call(exoticToPrim, input, « hint »).
>       - If Type(result) is not Object, return result.
>       - Throw a TypeError exception.
>    - If hint is "default", set hint to "number".
>    - Return ? OrdinaryToPrimitive(input, hint).
> 3. Return input. 

```js
function add (n) {
  function fn (x) {
    return add(n + x);
  }
  fn.valueOf = function(){
    return n;
  }
  return fn;
}
```